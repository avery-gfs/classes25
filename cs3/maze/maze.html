<!--
Generated by google gemini

prompts:

write a web app. the app will take a maze file string as a query string. an example maze string will look like this "%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%0D%0A%E2%96%88A%E2%96%88+++++%E2%96%88B%E2%96%88+++++++++%E2%96%88+++++++++%E2%96%88+%E2%96%88%0D%0A%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88%0D%0A%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+++++%E2%96%88+++++++%E2%96%88+%E2%96%88+++%E2%96%88+++%E2%96%88%0D%0A%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%0D%0A%E2%96%88+++%E2%96%88+%E2%96%88+++++%E2%96%88+++++%E2%96%88+%E2%96%88+%E2%96%88+++%E2%96%88+++++%E2%96%88%0D%0A%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88%0D%0A%E2%96%88+%E2%96%88+++++%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+++++++%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%0D%0A%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88%0D%0A%E2%96%88+%E2%96%88+++%E2%96%88+++%E2%96%88+%E2%96%88+++%E2%96%88+++%E2%96%88+++++++%E2%96%88+++%E2%96%88%0D%0A%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88%0D%0A%E2%96%88+%E2%96%88+++%E2%96%88+%E2%96%88+%E2%96%88+++++%E2%96%88+%E2%96%88+++%E2%96%88+++%E2%96%88+++%E2%96%88+%E2%96%88%0D%0A%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88%0D%0A%E2%96%88+%E2%96%88+++%E2%96%88+%E2%96%88+++++++%E2%96%88+++%E2%96%88+++%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%0D%0A%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%E2%96%88%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88+%E2%96%88%0D%0A%E2%96%88+++++%E2%96%88+++++++++++%E2%96%88+++%E2%96%88+++++%E2%96%88+++%E2%96%88%0D%0A%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88%E2%96%88"

the web app should allow the user to navigate from the cell marked A to the one marked B. But, the ui shouldn't show the maze to begin, only shows controls to user (up down left right) with directions that are blocked grayed out (not clickable). should keep track of how many moves the user has made as well as a log of the moves. should tell player once they reach the destination. the app should be a single file (html, css, js) you can use tailwind for styles. as the user explores the maze, the ui should show the parts of the maze the user has seen, including path travelled, current position, and walls adjacent to the path

the maze visualization is broken, do the vis using text chars, like how the maze is encoded. don't use tailwind

i like this ui, but take out the maze visualization entirely, just have the controls and the log, and use light theme

get rid of congradulations modal, just have a small indication that maze is solved. also keep use a different color for arrow directions which are valid, but which till take user to somewhere they're been before

light blue for previously visited arrow color . use unicode arrow emojis for direction log, not words

use light green to mark arrow for home direction (the arrow to previously visited cell from which current cell was first reached)

green should be used for direction from which current cell was first reached (originally, first time entered) not last reached

remove move log, rename page hidden maze navigator

add note explaining colors 

redo ui without tailwind
-->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hidden Maze Navigator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      /* General Body and Layout Styles */
      body {
        font-family: "Inter", sans-serif;
        background-color: #f3f4f6; /* bg-gray-100 */
        color: #1f2937; /* text-gray-800 */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 1rem;
        margin: 0;
      }

      .container {
        width: 100%;
        max-width: 24rem; /* max-w-sm */
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2rem;
      }

      /* Typography */
      h1 {
        font-size: 2.25rem; /* text-4xl */
        font-weight: 700;
        color: #3b82f6; /* text-blue-600 */
        letter-spacing: 0.025em;
        text-align: center;
      }

      .subtitle {
        color: #6b7280; /* text-gray-500 */
        text-align: center;
        margin-top: -1.5rem;
      }

      /* Controls Grid */
      .controls-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.75rem;
        width: 13rem; /* w-52 */
      }

      /* Control Buttons */
      .control-btn {
        background-color: #ffffff;
        color: #374151; /* text-gray-700 */
        border: 1px solid #d1d5db; /* border-gray-300 */
        border-radius: 0.5rem; /* rounded-lg */
        padding: 1rem;
        font-size: 1.5rem; /* text-2xl */
        transition: all 0.15s ease-in-out;
        cursor: pointer;
      }

      .control-btn:not(:disabled):hover {
        background-color: #3b82f6; /* hover:bg-blue-500 */
        color: #ffffff; /* hover:text-white */
      }

      .control-btn.is-home {
        background-color: #a7f3d0; /* bg-green-300 */
        color: #000000;
      }
      .control-btn.is-home:hover {
        background-color: #6ee7b7; /* hover:bg-green-400 */
      }

      .control-btn.is-backtrack {
        background-color: #bae6fd; /* bg-sky-300 */
        color: #000000;
      }
      .control-btn.is-backtrack:hover {
        background-color: #7dd3fc; /* hover:bg-sky-400 */
      }

      .control-btn:disabled {
        opacity: 0.2;
        cursor: not-allowed;
      }
      .control-btn:disabled:hover {
        background-color: #ffffff;
        color: #d1d5db;
      }

      /* Info Panel */
      .info-panel {
        width: 100%;
        background-color: #ffffff;
        padding: 1.5rem;
        border-radius: 0.5rem;
        box-shadow:
          0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
        border: 1px solid #e5e7eb; /* border-gray-200 */
      }

      .info-panel h2 {
        font-size: 1.5rem; /* text-2xl */
        font-weight: 700;
        border-bottom: 2px solid #3b82f6; /* border-blue-500 */
        padding-bottom: 0.5rem;
        margin-bottom: 1rem;
      }
      .info-panel h2.solved {
        border-color: #16a34a; /* border-green-500 */
        color: #15803d; /* text-green-600 */
      }

      .win-message {
        display: none;
        text-align: center;
        font-weight: 600;
        color: #15803d; /* text-green-600 */
        background-color: #dcfce7; /* bg-green-100 */
        padding: 0.75rem;
        border-radius: 0.375rem;
        margin-bottom: 1rem;
      }

      .info-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 1.125rem; /* text-lg */
        margin-bottom: 1rem;
      }

      .info-row span:first-child {
        font-weight: 500;
        color: #6b7280; /* text-gray-500 */
      }

      #move-count {
        font-size: 1.5rem; /* text-2xl */
        font-weight: 700;
        background-color: #e5e7eb; /* bg-gray-200 */
        padding: 0.25rem 0.75rem;
        border-radius: 0.375rem; /* rounded-md */
        color: #2563eb; /* text-blue-600 */
        font-family: monospace;
      }

      /* Color Key */
      .color-key {
        margin-top: 1.5rem;
        padding-top: 1rem;
        border-top: 2px solid #e5e7eb; /* border-gray-200 */
      }

      .color-key h3 {
        font-size: 1.125rem; /* text-lg */
        font-weight: 700;
        margin-bottom: 0.75rem;
        color: #4b5563; /* text-gray-600 */
      }

      .key-items-container {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        font-size: 0.875rem; /* text-sm */
        color: #374151; /* text-gray-700 */
      }

      .key-item {
        display: flex;
        align-items: center;
      }

      .key-swatch {
        width: 1rem;
        height: 1rem;
        border-radius: 9999px; /* rounded-full */
        margin-right: 0.75rem;
        border: 2px solid transparent;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Hidden Maze Navigator</h1>
      <p class="subtitle">Navigate the unseen maze from 'A' to 'B'.</p>

      <!-- Controls -->
      <div class="controls-grid">
        <div></div>
        <button id="btn-up" class="control-btn">▲</button>
        <div></div>
        <button id="btn-left" class="control-btn">◀</button>
        <button id="btn-down" class="control-btn">▼</button>
        <button id="btn-right" class="control-btn">▶</button>
      </div>

      <!-- Info Panel -->
      <div class="info-panel">
        <h2 id="game-info-header">Game Info</h2>
        <div id="win-message" class="win-message"></div>
        <div class="info-row">
          <span>Moves:</span>
          <span id="move-count">0</span>
        </div>

        <!-- Color Key -->
        <div class="color-key">
          <h3>Arrow Color Key</h3>
          <div class="key-items-container">
            <div class="key-item">
              <div class="key-swatch" style="border-color: #888"></div>
              <span>New Path (Hover)</span>
            </div>
            <div class="key-item">
              <div class="key-swatch" style="background-color: #bae6fd"></div>
              <span>Previously Visited Path</span>
            </div>
            <div class="key-item">
              <div class="key-swatch" style="background-color: #a7f3d0"></div>
              <span>Path to Previous Cell</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // --- Game State ---
        let mazeGrid = [];
        let playerPos = { y: 0, x: 0 };
        let startPos = { y: 0, x: 0 };
        let endPos = { y: 0, x: 0 };
        let moveCount = 0;
        const visitedCells = new Set();
        const pathMap = new Map(); // Stores the "parent" of each cell
        let isGameOver = false;

        // --- DOM Elements ---
        const moveCountDisplay = document.getElementById("move-count");
        const gameInfoHeader = document.getElementById("game-info-header");
        const winMessage = document.getElementById("win-message");

        const buttons = {
          up: document.getElementById("btn-up"),
          down: document.getElementById("btn-down"),
          left: document.getElementById("btn-left"),
          right: document.getElementById("btn-right"),
        };

        // --- Default Maze (if no query string is provided) ---
        const defaultMazeString = `███████████████
█A█     █B█   █
█ █ ███ █ ███ █
█ █ █ █ █     █
█ █ █ █ █████ █
█   █ █     █ █
█ ███ █████ █ █
█     █       █
███████████████`;

        // --- Initialization ---
        function init() {
          const urlParams = new URLSearchParams(window.location.search);
          const mazeQuery = urlParams.get("maze");
          const mazeString = mazeQuery
            ? decodeURIComponent(mazeQuery)
            : defaultMazeString;

          parseMaze(mazeString);
          if (!startPos || !endPos) {
            document.body.innerHTML = `<div style="color: red; text-align: center; padding: 2rem;">Error: Maze must contain a starting point 'A' and an ending point 'B'.</div>`;
            return;
          }

          playerPos = { ...startPos };
          visitedCells.add(`${startPos.y},${startPos.x}`);

          updateControls();
          setupEventListeners();
        }

        // --- Maze Parsing ---
        function parseMaze(mazeString) {
          mazeGrid = mazeString.split("\n").map((row) => row.split(""));
          for (let y = 0; y < mazeGrid.length; y++) {
            for (let x = 0; x < mazeGrid[y].length; x++) {
              if (mazeGrid[y][x] === "A") {
                startPos = { y, x };
              } else if (mazeGrid[y][x] === "B") {
                endPos = { y, x };
              }
            }
          }
        }

        // --- Game Logic ---
        function movePlayer(direction) {
          if (isGameOver) return;

          const moves = {
            up: { y: -1, x: 0 },
            down: { y: 1, x: 0 },
            left: { y: 0, x: -1 },
            right: { y: 0, x: 1 },
          };

          const move = moves[direction];
          const newPos = { y: playerPos.y + move.y, x: playerPos.x + move.x };

          if (isValidMove(newPos)) {
            const newPosCoordString = `${newPos.y},${newPos.x}`;
            if (!visitedCells.has(newPosCoordString)) {
              pathMap.set(newPosCoordString, `${playerPos.y},${playerPos.x}`);
            }

            playerPos = newPos;
            visitedCells.add(newPosCoordString);
            moveCount++;

            updateUI();
            checkForWin();
          }
        }

        function isValidMove({ y, x }) {
          return (
            y >= 0 &&
            y < mazeGrid.length &&
            x >= 0 &&
            x < mazeGrid[y].length &&
            mazeGrid[y][x] !== "█"
          );
        }

        function checkForWin() {
          if (playerPos.y === endPos.y && playerPos.x === endPos.x) {
            isGameOver = true;
            gameInfoHeader.textContent = "Maze Solved!";
            gameInfoHeader.classList.add("solved");
            winMessage.textContent = `Completed in ${moveCount} moves!`;
            winMessage.style.display = "block";
            updateControls(); // To disable all buttons
          }
        }

        // --- UI Updates ---
        function updateUI() {
          updateControls();
          moveCountDisplay.textContent = moveCount;
        }

        function updateControls() {
          const directions = {
            up: { y: -1, x: 0 },
            down: { y: 1, x: 0 },
            left: { y: 0, x: -1 },
            right: { y: 0, x: 1 },
          };

          if (isGameOver) {
            Object.values(buttons).forEach((btn) => (btn.disabled = true));
            return;
          }

          const parentCoordString = pathMap.get(
            `${playerPos.y},${playerPos.x}`,
          );

          for (const [dir, move] of Object.entries(directions)) {
            const btn = buttons[dir];
            const newPos = { y: playerPos.y + move.y, x: playerPos.x + move.x };
            const newPosCoordString = `${newPos.y},${newPos.x}`;

            // Reset classes
            btn.className = "control-btn";

            if (!isValidMove(newPos)) {
              btn.disabled = true;
            } else {
              btn.disabled = false;
              if (
                parentCoordString &&
                newPosCoordString === parentCoordString
              ) {
                btn.classList.add("is-home");
              } else if (visitedCells.has(newPosCoordString)) {
                btn.classList.add("is-backtrack");
              }
            }
          }
        }

        // --- Event Listeners ---
        function setupEventListeners() {
          buttons.up.addEventListener("click", () => movePlayer("up"));
          buttons.down.addEventListener("click", () => movePlayer("down"));
          buttons.left.addEventListener("click", () => movePlayer("left"));
          buttons.right.addEventListener("click", () => movePlayer("right"));

          document.addEventListener("keydown", (e) => {
            if (isGameOver) return;
            switch (e.key) {
              case "ArrowUp":
              case "w":
                e.preventDefault();
                buttons.up.click();
                break;
              case "ArrowDown":
              case "s":
                e.preventDefault();
                buttons.down.click();
                break;
              case "ArrowLeft":
              case "a":
                e.preventDefault();
                buttons.left.click();
                break;
              case "ArrowRight":
              case "d":
                e.preventDefault();
                buttons.right.click();
                break;
            }
          });
        }

        init();
      });
    </script>
  </body>
</html>
