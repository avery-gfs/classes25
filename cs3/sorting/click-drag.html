<!--
Generated by google gemini

prompts:

make a html web app (as a standalone file) that lets the user enter a string of text, and splits the text into items by comma delimiters, and shows each item as a card on the screen that can be clicked / dragged to move it around. for example if the user entered ðŸ¥¦, ðŸ«–, ðŸ§², ðŸ’©, ðŸ¼, ðŸ„, ðŸ€, ðŸª­, ðŸ¦˜, ðŸ¦€ it would show 10 cards each with an emoji. the user should be able to change the text string and have the cards regenerate, and should save the text string in localstorage for next time (don't have to save positions). also include a reset positions button which arranges the cards in some default layout.

good, i like that it strips whitespace by default. clicking / dragging a card should bring it to the front of the stacking order. open up the droppable workspace to fill the rest of the height of the screen after the control bar at the top

the changes are good but now the cards are locked to their starting y position 

still seeing the same error 
-->

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Draggable Card Sorter</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
      }
      body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f4;
        color: #333;
        display: flex;
        flex-direction: column;
      }
      #controls {
        padding: 15px 20px;
        background-color: #fff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 15px;
        flex-shrink: 0;
      }
      #controls h1 {
        font-size: 1.5em;
        margin: 0;
        margin-right: auto;
      }
      #controls label {
        font-weight: bold;
      }
      #textInput {
        flex-grow: 1;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 1em;
        min-width: 200px;
      }
      button {
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        background-color: #007bff;
        color: white;
        cursor: pointer;
        font-size: 1em;
        transition: background-color 0.2s ease;
      }
      button:hover {
        background-color: #0056b3;
      }
      #cardContainer {
        position: relative;
        background-color: #e9e9e9;
        padding: 10px;
        overflow: hidden;
        flex-grow: 1;
      }
      .card {
        position: absolute;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        cursor: grab;
        font-size: 1.5em;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 80px;
        height: 80px;
        user-select: none;
        transition:
          box-shadow 0.2s ease,
          transform 0.1s ease;
        z-index: 10;
      }
      .card:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      }
      .card.dragging {
        cursor: grabbing;
        transform: scale(1.02);
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <h1>Card Sorter</h1>
      <label for="textInput">Items:</label>
      <input
        type="text"
        id="textInput"
        placeholder="e.g., Apple, Banana, Cherry"
      />
      <button onclick="generateCards()">Generate</button>
      <button onclick="resetCardPositions()">Reset Positions</button>
    </div>

    <div id="cardContainer"></div>

    <script>
      const textInput = document.getElementById("textInput");
      const cardContainer = document.getElementById("cardContainer");
      const localStorageKey = "draggableCardSorterText";

      // FIXED: Variables for new drag logic
      let activeCard = null;
      let zIndexCounter = 10;
      let initialCardX, initialCardY;
      let initialMouseX, initialMouseY;

      document.addEventListener("DOMContentLoaded", () => {
        const savedText = localStorage.getItem(localStorageKey);
        if (savedText) {
          textInput.value = savedText;
          generateCards();
        }
      });

      function generateCards() {
        const inputText = textInput.value;
        localStorage.setItem(localStorageKey, inputText);
        cardContainer.innerHTML = "";

        if (inputText.trim() === "") return;

        const items = inputText
          .split(",")
          .map((item) => item.trim())
          .filter((item) => item !== "");
        zIndexCounter = 10;

        items.forEach((item, index) => {
          const card = document.createElement("div");
          card.classList.add("card");
          card.textContent = item;
          card.id = `card-${index}`;

          const containerWidth = cardContainer.clientWidth || window.innerWidth;
          const cardWidth = 80;
          const cardsPerRow = Math.max(
            1,
            Math.floor(containerWidth / (cardWidth + 20)),
          );
          const row = Math.floor(index / cardsPerRow);
          const col = index % cardsPerRow;

          card.style.left = `${10 + col * (cardWidth + 20)}px`;
          card.style.top = `${10 + row * (80 + 20)}px`;

          cardContainer.appendChild(card);
        });

        addDragListeners();
      }

      function addDragListeners() {
        document.querySelectorAll(".card").forEach((card) => {
          card.addEventListener("mousedown", dragStart);
          card.addEventListener("touchstart", dragStart, { passive: false });
        });
      }

      // --- DRAG LOGIC REWRITTEN ---

      function dragStart(e) {
        activeCard = e.target.closest(".card");
        if (!activeCard) return;

        zIndexCounter++;
        activeCard.style.zIndex = zIndexCounter;
        activeCard.classList.add("dragging");

        if (e.type === "touchstart") {
          initialMouseX = e.touches[0].clientX;
          initialMouseY = e.touches[0].clientY;
        } else {
          e.preventDefault();
          initialMouseX = e.clientX;
          initialMouseY = e.clientY;
        }

        // Store the card's initial position
        initialCardX = activeCard.offsetLeft;
        initialCardY = activeCard.offsetTop;

        document.addEventListener("mousemove", dragMove);
        document.addEventListener("mouseup", dragEnd);
        document.addEventListener("touchmove", dragMove, { passive: false });
        document.addEventListener("touchend", dragEnd);
      }

      function dragMove(e) {
        if (!activeCard) return;

        let currentMouseX, currentMouseY;
        if (e.type === "touchmove") {
          e.preventDefault();
          currentMouseX = e.touches[0].clientX;
          currentMouseY = e.touches[0].clientY;
        } else {
          currentMouseX = e.clientX;
          currentMouseY = e.clientY;
        }

        // Calculate the distance the mouse has moved
        const deltaX = currentMouseX - initialMouseX;
        const deltaY = currentMouseY - initialMouseY;

        // Calculate the new card position
        let newLeft = initialCardX + deltaX;
        let newTop = initialCardY + deltaY;

        // Constrain to container boundaries
        const containerRect = cardContainer.getBoundingClientRect();
        newLeft = Math.max(
          0,
          Math.min(newLeft, containerRect.width - activeCard.offsetWidth),
        );
        newTop = Math.max(
          0,
          Math.min(newTop, containerRect.height - activeCard.offsetHeight),
        );

        activeCard.style.left = `${newLeft}px`;
        activeCard.style.top = `${newTop}px`;
      }

      function dragEnd() {
        if (activeCard) {
          activeCard.classList.remove("dragging");
          activeCard = null;
        }
        document.removeEventListener("mousemove", dragMove);
        document.removeEventListener("mouseup", dragEnd);
        document.removeEventListener("touchmove", dragMove);
        document.removeEventListener("touchend", dragEnd);
      }

      function resetCardPositions() {
        generateCards();
      }
    </script>
  </body>
</html>
