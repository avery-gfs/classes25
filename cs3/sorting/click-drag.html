<!--
Generated by google gemini

prompts:

make a html web app (as a standalone file) that lets the user enter a string of text, and splits the text into items by comma delimiters, and shows each item as a card on the screen that can be clicked / dragged to move it around. for example if the user entered 🥦, 🫖, 🧲, 💩, 🐼, 🍄, 🏀, 🪭, 🦘, 🦀, ⚽, 🥑 it would show 12 cards each with an emoji. the user should be able to change the text string and have the cards regenerate, and should save the text string in localstorage for next time (don't have to save positions). also include a reset positions button which arranges the cards in some default layout.

good, i like that it strips whitespace by default. clicking / dragging a card should bring it to the front of the stacking order. open up the droppable workspace to fill the rest of the height of the screen after the control bar at the top

the changes are good but now the cards are locked to their starting y position

still seeing the same error 

add string as query param so link can be saved, changing input string should update query string, get rid of localhost storage 

update this code so i can click outside and drag to box select multiple cards and move them all at once, deselecting all when i click outside of selected cards
-->

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Draggable Card Sorter</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
      }
      body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f4;
        color: #333;
        display: flex;
        flex-direction: column;
      }
      #controls {
        padding: 15px 20px;
        background-color: #fff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 15px;
        flex-shrink: 0;
      }
      #controls h1 {
        font-size: 1.5em;
        margin: 0;
        margin-right: auto;
      }
      #controls label {
        font-weight: bold;
      }
      #textInput {
        flex-grow: 1;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 1em;
        min-width: 200px;
      }
      button {
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        background-color: #007bff;
        color: white;
        cursor: pointer;
        font-size: 1em;
        transition: background-color 0.2s ease;
      }
      button:hover {
        background-color: #0056b3;
      }
      #cardContainer {
        position: relative;
        background-color: #e9e9e9;
        padding: 10px;
        overflow: hidden;
        flex-grow: 1;
      }
      .card {
        position: absolute;
        background-color: #fff;
        border: 2px solid #ddd;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        cursor: grab;
        font-size: 2em;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 80px;
        height: 80px;
        user-select: none;
        transition:
          box-shadow 0.2s ease,
          transform 0.1s ease,
          background-color 0.2s ease,
          border-color 0.2s ease;
        z-index: 10;
      }
      .card:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
      }
      .card.dragging {
        cursor: grabbing;
        transform: scale(1.02);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      }
      /* --- NEW STYLES --- */
      .card.selected {
        border-color: #007bff;
        background-color: #e6f2ff;
      }
      #selectionBox {
        position: absolute;
        border: 1px dashed #333;
        background-color: rgba(0, 123, 255, 0.2);
        z-index: 9999;
        display: none;
        pointer-events: none; /* Allows clicks to go through the box */
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <h1>Card Sorter</h1>
      <label for="textInput">Items:</label>
      <input
        type="text"
        id="textInput"
        placeholder="e.g., Apple, Banana, Cherry"
      />
      <button onclick="generateCards()">Generate</button>
      <button onclick="resetCardPositions()">Reset Positions</button>
    </div>

    <div id="cardContainer"></div>

    <script>
      const textInput = document.getElementById("textInput");
      const cardContainer = document.getElementById("cardContainer");

      // --- STATE VARIABLES ---
      let selectedCards = new Set();
      let initialCardPositions = new Map();
      let zIndexCounter = 10;
      let initialMouseX, initialMouseY;
      let isDraggingCards = false;
      let isBoxSelecting = false;
      let selectionBox = null;
      let boxStartX = 0;
      let boxStartY = 0;

      // --- INITIALIZATION ---
      document.addEventListener("DOMContentLoaded", () => {
        // Create the selection box element
        selectionBox = document.createElement("div");
        selectionBox.id = "selectionBox";
        cardContainer.appendChild(selectionBox);

        // Add main container listeners for box selection and deselection
        cardContainer.addEventListener("mousedown", containerMouseDown);

        // Load state from URL on startup
        const params = new URLSearchParams(window.location.search);
        if (params.has("q")) {
          textInput.value = params.get("q");
          generateCards();
        }
      });

      // --- URL MANAGEMENT ---
      function updateURL(text) {
        const url = new URL(window.location);
        if (text.trim()) {
          url.searchParams.set("q", text);
        } else {
          url.searchParams.delete("q");
        }
        window.history.replaceState({}, "", url);
      }

      // --- CARD GENERATION & RESET ---
      function generateCards() {
        const inputText = textInput.value;
        updateURL(inputText);

        cardContainer.innerHTML = "";
        cardContainer.appendChild(selectionBox); // Re-append after clearing
        deselectAllCards();
        if (inputText.trim() === "") return;

        const items = inputText
          .split(",")
          .map((item) => item.trim())
          .filter((item) => item !== "");
        zIndexCounter = 10;

        items.forEach((item, index) => {
          const card = document.createElement("div");
          card.classList.add("card");
          card.textContent = item;
          card.id = `card-${index}`;

          const containerWidth = cardContainer.clientWidth || window.innerWidth;
          const cardWidth = 80;
          const cardsPerRow = Math.max(
            1,
            Math.floor(containerWidth / (cardWidth + 20)),
          );
          const row = Math.floor(index / cardsPerRow);
          const col = index % cardsPerRow;

          card.style.left = `${10 + col * (cardWidth + 20)}px`;
          card.style.top = `${10 + row * (80 + 20)}px`;

          cardContainer.appendChild(card);
          // Add listeners to each new card
          card.addEventListener("mousedown", cardMouseDown);
          card.addEventListener("touchstart", cardMouseDown, {
            passive: false,
          });
        });
      }

      function resetCardPositions() {
        generateCards();
      }

      // --- SELECTION HELPERS ---
      function isIntersecting(rect1, rect2) {
        return !(
          rect1.right < rect2.left ||
          rect1.left > rect2.right ||
          rect1.bottom < rect2.top ||
          rect1.top > rect2.bottom
        );
      }

      function deselectAllCards() {
        selectedCards.forEach((card) => card.classList.remove("selected"));
        selectedCards.clear();
      }

      // --- MOUSE EVENT HANDLERS ---

      // Handles mousedown on a card to initiate a drag
      function cardMouseDown(e) {
        e.stopPropagation(); // Prevent container's mousedown from firing

        const clickedCard = e.currentTarget;
        isDraggingCards = true;

        if (!clickedCard.classList.contains("selected")) {
          deselectAllCards();
          selectedCards.add(clickedCard);
          clickedCard.classList.add("selected");
        }

        zIndexCounter++;
        initialMouseX = e.type.startsWith("touch")
          ? e.touches[0].clientX
          : e.clientX;
        initialMouseY = e.type.startsWith("touch")
          ? e.touches[0].clientY
          : e.clientY;

        initialCardPositions.clear();
        selectedCards.forEach((card) => {
          card.style.zIndex = zIndexCounter;
          card.classList.add("dragging");
          initialCardPositions.set(card, {
            x: card.offsetLeft,
            y: card.offsetTop,
          });
        });

        document.addEventListener("mousemove", dragMove);
        document.addEventListener("mouseup", dragEnd);
        document.addEventListener("touchmove", dragMove, { passive: false });
        document.addEventListener("touchend", dragEnd);
      }

      // Handles mousedown on the background to deselect or start box selection
      function containerMouseDown(e) {
        if (e.target !== cardContainer) return;

        deselectAllCards();
        isBoxSelecting = true;

        const containerRect = cardContainer.getBoundingClientRect();
        boxStartX = e.clientX - containerRect.left;
        boxStartY = e.clientY - containerRect.top;

        Object.assign(selectionBox.style, {
          left: `${boxStartX}px`,
          top: `${boxStartY}px`,
          width: "0px",
          height: "0px",
          display: "block",
        });

        document.addEventListener("mousemove", boxSelectMove);
        document.addEventListener("mouseup", boxSelectEnd);
      }

      // --- MOVE HANDLERS ---

      // Moves all selected cards
      function dragMove(e) {
        if (!isDraggingCards) return;
        e.preventDefault();

        const currentX = e.type.startsWith("touch")
          ? e.touches[0].clientX
          : e.clientX;
        const currentY = e.type.startsWith("touch")
          ? e.touches[0].clientY
          : e.clientY;
        const deltaX = currentX - initialMouseX;
        const deltaY = currentY - initialMouseY;
        const containerRect = cardContainer.getBoundingClientRect();

        selectedCards.forEach((card) => {
          const initialPos = initialCardPositions.get(card);
          if (!initialPos) return;

          let newLeft = initialPos.x + deltaX;
          let newTop = initialPos.y + deltaY;

          newLeft = Math.max(
            0,
            Math.min(newLeft, containerRect.width - card.offsetWidth),
          );
          newTop = Math.max(
            0,
            Math.min(newTop, containerRect.height - card.offsetHeight),
          );

          card.style.left = `${newLeft}px`;
          card.style.top = `${newTop}px`;
        });
      }

      // Resizes the selection box and updates selected cards
      function boxSelectMove(e) {
        if (!isBoxSelecting) return;

        const containerRect = cardContainer.getBoundingClientRect();
        const currentX = e.clientX - containerRect.left;
        const currentY = e.clientY - containerRect.top;

        const left = Math.min(boxStartX, currentX);
        const top = Math.min(boxStartY, currentY);
        const width = Math.abs(currentX - boxStartX);
        const height = Math.abs(currentY - boxStartY);

        Object.assign(selectionBox.style, {
          left: `${left}px`,
          top: `${top}px`,
          width: `${width}px`,
          height: `${height}px`,
        });

        const boxRect = selectionBox.getBoundingClientRect();
        document.querySelectorAll(".card").forEach((card) => {
          if (isIntersecting(boxRect, card.getBoundingClientRect())) {
            if (!selectedCards.has(card)) {
              selectedCards.add(card);
              card.classList.add("selected");
            }
          } else {
            if (selectedCards.has(card)) {
              selectedCards.delete(card);
              card.classList.remove("selected");
            }
          }
        });
      }

      // --- END HANDLERS ---

      // Cleans up after dragging cards
      function dragEnd() {
        isDraggingCards = false;
        selectedCards.forEach((card) => card.classList.remove("dragging"));

        document.removeEventListener("mousemove", dragMove);
        document.removeEventListener("mouseup", dragEnd);
        document.removeEventListener("touchmove", dragMove);
        document.removeEventListener("touchend", dragEnd);
      }

      // Cleans up after box selection
      function boxSelectEnd() {
        isBoxSelecting = false;
        selectionBox.style.display = "none";

        document.removeEventListener("mousemove", boxSelectMove);
        document.removeEventListener("mouseup", boxSelectEnd);
      }
    </script>
  </body>
</html>
